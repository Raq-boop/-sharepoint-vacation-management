import { useState, useEffect, useCallback } from 'react';
import { WebPartContext } from '@microsoft/sp-webpart-base';
import PedidoFeriasService from '../services/PedidoFeriasService';
import { 
  IPedidoFerias, 
  INewPedidoFerias, 
  IPedidoUpdate, 
  IPedidoFeriasFilters, 
  ISortConfig, 

  IUserPermissions,
  IColaborador
} from '../models/IPedidoFerias';

export interface IUsePedidoFeriasState {
  // Estado dos pedidos
  pedidos: IPedidoFerias[];
  totalCount: number;
  hasNext: boolean;
  
  // Estados de loading
  isLoading: boolean;
  isCreating: boolean;
  isUpdating: boolean;
  isDeleting: boolean;
  isSearching: boolean;
  
  // Estado de erro
  error: string | null;
  
  // Configurações atuais
  currentFilters: IPedidoFeriasFilters | null;
  currentSort: ISortConfig | null;
  currentPage: number;
  pageSize: number;
  
  // Permissões do usuário
  userPermissions: IUserPermissions | null;
}

export interface IUsePedidoFeriasActions {
  // Operações de busca
  loadPedidos: (
    filters?: IPedidoFeriasFilters,
    sortConfig?: ISortConfig,
    page?: number
  ) => Promise<void>;
  refreshPedidos: () => Promise<void>;
  loadMorePedidos: () => Promise<void>;
  
  // Operações CRUD
  createPedido: (pedido: INewPedidoFerias) => Promise<IPedidoFerias | null>;
  updatePedidoStatus: (
    id: number,
    update: IPedidoUpdate
  ) => Promise<boolean>;
  deletePedido: (id: number) => Promise<boolean>;
  
  // Operações de filtro e ordenação
  setFilters: (filters: IPedidoFeriasFilters | null) => void;
  setSortConfig: (sortConfig: ISortConfig | null) => void;
  setPageSize: (size: number) => void;
  goToPage: (page: number) => void;
  
  // Busca de colaboradores
  searchColaboradores: (searchText: string) => Promise<IColaborador[]>;
  
  // Utilidades
  clearError: () => void;
  resetState: () => void;
}

export interface IUsePedidoFeriasReturn extends IUsePedidoFeriasState, IUsePedidoFeriasActions {}

const initialState: IUsePedidoFeriasState = {
  pedidos: [],
  totalCount: 0,
  hasNext: false,
  isLoading: false,
  isCreating: false,
  isUpdating: false,
  isDeleting: false,
  isSearching: false,
  error: null,
  currentFilters: null,
  currentSort: null,
  currentPage: 0,
  pageSize: 20,
  userPermissions: null
};

export const usePedidoFerias = (
  context: WebPartContext,
  listTitle?: string
): IUsePedidoFeriasReturn => {
  const [state, setState] = useState<IUsePedidoFeriasState>(initialState);
  const [service] = useState(() => new PedidoFeriasService(context, listTitle));

  /**
   * Atualizar estado de forma segura
   */
  const updateState = useCallback((updates: Partial<IUsePedidoFeriasState>) => {
    setState(prevState => ({ ...prevState, ...updates }));
  }, []);

  /**
   * Tratar erros de forma consistente
   */
  const handleError = useCallback((error: Error | unknown, operation: string) => {
    const errorMessage = error instanceof Error 
      ? error.message 
      : `Erro desconhecido na operação: ${operation}`;
    
    console.error(`usePedidoFerias - ${operation}:`, error);
    updateState({ 
      error: errorMessage,
      isLoading: false,
      isCreating: false,
      isUpdating: false,
      isDeleting: false,
      isSearching: false
    });
  }, [updateState]);

  /**
   * Carregar pedidos com filtros e ordenação
   */
  const loadPedidos = useCallback(async (
    filters?: IPedidoFeriasFilters,
    sortConfig?: ISortConfig,
    page: number = 0
  ) => {
    try {
      updateState({ isLoading: true, error: null });
      
      const result = await service.getPedidos(
        filters || state.currentFilters || undefined,
        sortConfig || state.currentSort || undefined,
        state.pageSize,
        page
      );
      
      if (result) {
        updateState({
          pedidos: page === 0 ? result.items : [...state.pedidos, ...result.items],
          totalCount: result.totalCount,
          hasNext: result.hasNext,
          currentFilters: filters || state.currentFilters,
          currentSort: sortConfig || state.currentSort,
          currentPage: page,
          isLoading: false
        });
      }
    } catch (error) {
      handleError(error, 'loadPedidos');
    }
  }, [service, state.currentFilters, state.currentSort, state.pageSize, state.pedidos, updateState, handleError]);

  /**
   * Recarregar pedidos (limpa cache)
   */
  const refreshPedidos = useCallback(async () => {
    await loadPedidos(state.currentFilters || undefined, state.currentSort || undefined, 0);
  }, [loadPedidos, state.currentFilters, state.currentSort]);

  /**
   * Carregar mais pedidos (paginação)
   */
  const loadMorePedidos = useCallback(async () => {
    if (state.hasNext && !state.isLoading) {
      await loadPedidos(
        state.currentFilters || undefined,
        state.currentSort || undefined,
        state.currentPage + 1
      );
    }
  }, [loadPedidos, state.hasNext, state.isLoading, state.currentFilters, state.currentSort, state.currentPage]);

  /**
   * Criar novo pedido
   */
  const createPedido = useCallback(async (pedido: INewPedidoFerias): Promise<IPedidoFerias | null> => {
    try {
      updateState({ isCreating: true, error: null });
      
      const newPedido = await service.createPedido(pedido);
      
      if (newPedido) {
        // Atualizar lista local
        updateState({
          pedidos: [newPedido, ...state.pedidos],
          totalCount: state.totalCount + 1,
          isCreating: false
        });
        
        return newPedido;
      }
      
      updateState({ isCreating: false });
      return null;
    } catch (error) {
      handleError(error, 'createPedido');
      return null;
    }
  }, [service, state.pedidos, state.totalCount, updateState, handleError]);

  /**
   * Atualizar status do pedido
   */
  const updatePedidoStatus = useCallback(async (
    id: number,
    update: IPedidoUpdate
  ): Promise<boolean> => {
    try {
      updateState({ isUpdating: true, error: null });
      
      // Obter ID do usuário atual (simplificado)
      const currentUser = await service['_sp'].web.currentUser();
      const success = await service.updatePedidoStatus(id, update, currentUser.Id);
      
      if (success) {
        // Atualizar pedido na lista local
        const updatedPedidos = state.pedidos.map(pedido => 
          pedido.Id === id 
            ? { 
                ...pedido, 
                Estado: update.Estado,
                DataAprovacao: new Date().toISOString(),
                AprovadoPor: { Id: currentUser.Id, Title: currentUser.Title },
                Observacoes: update.Observacoes || pedido.Observacoes
              }
            : pedido
        );
        
        updateState({
          pedidos: updatedPedidos,
          isUpdating: false
        });
        
        return true;
      }
      
      updateState({ isUpdating: false });
      return false;
    } catch (error) {
      handleError(error, 'updatePedidoStatus');
      return false;
    }
  }, [service, state.pedidos, updateState, handleError]);

  /**
   * Excluir pedido
   */
  const deletePedido = useCallback(async (id: number): Promise<boolean> => {
    try {
      updateState({ isDeleting: true, error: null });
      
      const success = await service.deletePedido(id);
      
      if (success) {
        // Remover pedido da lista local
        const filteredPedidos = state.pedidos.filter(pedido => pedido.Id !== id);
        updateState({
          pedidos: filteredPedidos,
          totalCount: state.totalCount - 1,
          isDeleting: false
        });
        
        return true;
      }
      
      updateState({ isDeleting: false });
      return false;
    } catch (error) {
      handleError(error, 'deletePedido');
      return false;
    }
  }, [service, state.pedidos, state.totalCount, updateState, handleError]);

  /**
   * Definir filtros
   */
  const setFilters = useCallback((filters: IPedidoFeriasFilters | null) => {
    updateState({ currentFilters: filters });
    // Auto-aplicar filtros
    void loadPedidos(filters || undefined, state.currentSort || undefined, 0);
  }, [loadPedidos, state.currentSort, updateState]);

  /**
   * Definir configuração de ordenação
   */
  const setSortConfig = useCallback((sortConfig: ISortConfig | null) => {
    updateState({ currentSort: sortConfig });
    // Auto-aplicar ordenação
    void loadPedidos(state.currentFilters || undefined, sortConfig || undefined, 0);
  }, [loadPedidos, state.currentFilters, updateState]);

  /**
   * Definir tamanho da página
   */
  const setPageSize = useCallback((size: number) => {
    updateState({ pageSize: size });
  }, [updateState]);

  /**
   * Ir para página específica
   */
  const goToPage = useCallback((page: number) => {
    loadPedidos(state.currentFilters || undefined, state.currentSort || undefined, page);
  }, [loadPedidos, state.currentFilters, state.currentSort]);

  /**
   * Buscar colaboradores
   */
  const searchColaboradores = useCallback(async (searchText: string): Promise<IColaborador[]> => {
    try {
      updateState({ isSearching: true, error: null });
      
      const colaboradores = await service.searchColaboradores(searchText);
      
      updateState({ isSearching: false });
      return colaboradores;
    } catch (error) {
      handleError(error, 'searchColaboradores');
      return [];
    }
  }, [service, updateState, handleError]);

  /**
   * Limpar erro
   */
  const clearError = useCallback(() => {
    updateState({ error: null });
  }, [updateState]);

  /**
   * Resetar estado
   */
  const resetState = useCallback(() => {
    setState(initialState);
  }, []);

  /**
   * Carregar permissões do usuário ao inicializar
   */
  useEffect(() => {
    const loadUserPermissions = async () => {
      try {
        const permissions = await service.getCurrentUserPermissions();
        updateState({ userPermissions: permissions || null });
      } catch (error) {
        console.warn('Erro ao carregar permissões do usuário:', error);
      }
    };

    loadUserPermissions();
  }, [service, updateState]);

  /**
   * Carregar pedidos iniciais
   */
  useEffect(() => {
    loadPedidos();
  }, []); // Apenas na montagem inicial

  return {
    // Estado
    ...state,
    
    // Ações
    loadPedidos,
    refreshPedidos,
    loadMorePedidos,
    createPedido,
    updatePedidoStatus,
    deletePedido,
    setFilters,
    setSortConfig,
    setPageSize,
    goToPage,
    searchColaboradores,
    clearError,
    resetState
  };
};

export default usePedidoFerias;